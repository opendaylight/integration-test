
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
class yc_null_address_ietf_lisp_address_types__eid_null_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/null-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Null body LCAF type
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__address',)

  _yang_name = 'null-address'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'null-address']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/null_address/address (empty)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/null_address/address (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)

  address = property(_get_address, _set_address)

  __choices__ = {u'address': {u'null-address': [u'address']}}
  _pyangbind_elements = {'address': address, }


class yc_afi_list_ietf_lisp_address_types__eid_afi_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/afi-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AFI-List LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__address_list',)

  _yang_name = 'afi-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_list = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="address-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'afi-list']

  def _get_address_list(self):
    """
    Getter method for address_list, mapped from YANG variable /eid/afi_list/address_list (simple-address)

    YANG Description: List of AFI addresses.
    """
    return self.__address_list
      
  def _set_address_list(self, v, load=False):
    """
    Setter method for address_list, mapped from YANG variable /eid/afi_list/address_list (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_list() directly.

    YANG Description: List of AFI addresses.
    """
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="address-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_list must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="address-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_list(self):
    self.__address_list = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="address-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  address_list = property(_get_address_list, _set_address_list)

  __choices__ = {u'address': {u'afi-list': [u'address_list']}}
  _pyangbind_elements = {'address_list': address_list, }


class yc_instance_id_ietf_lisp_address_types__eid_instance_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/instance-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instance ID LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__iid','__mask_length','__address',)

  _yang_name = 'instance-id'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__iid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="iid", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mask-length", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'instance-id']

  def _get_iid(self):
    """
    Getter method for iid, mapped from YANG variable /eid/instance_id/iid (instance-id-type)

    YANG Description: Instance ID value.
    """
    return self.__iid
      
  def _set_iid(self, v, load=False):
    """
    Setter method for iid, mapped from YANG variable /eid/instance_id/iid (instance-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iid() directly.

    YANG Description: Instance ID value.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="iid", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iid must be of a type compatible with instance-id-type""",
          'defined-type': "ietf-lisp-address-types:instance-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="iid", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)""",
        })

    self.__iid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iid(self):
    self.__iid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="iid", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)


  def _get_mask_length(self):
    """
    Getter method for mask_length, mapped from YANG variable /eid/instance_id/mask_length (uint8)

    YANG Description: Mask length.
    """
    return self.__mask_length
      
  def _set_mask_length(self, v, load=False):
    """
    Setter method for mask_length, mapped from YANG variable /eid/instance_id/mask_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask_length() directly.

    YANG Description: Mask length.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mask-length", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mask-length", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__mask_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask_length(self):
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mask-length", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/instance_id/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/instance_id/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  iid = property(_get_iid, _set_iid)
  mask_length = property(_get_mask_length, _set_mask_length)
  address = property(_get_address, _set_address)

  __choices__ = {u'address': {u'instance-id': [u'iid', u'mask_length', u'address']}}
  _pyangbind_elements = {'iid': iid, 'mask_length': mask_length, 'address': address, }


class yc_as_number_lcaf_ietf_lisp_address_types__eid_as_number_lcaf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/as-number-lcaf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AS Number LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__as_','__address',)

  _yang_name = 'as-number-lcaf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'as-number-lcaf']

  def _get_as_(self):
    """
    Getter method for as_, mapped from YANG variable /eid/as_number_lcaf/as (inet:as-number)

    YANG Description: AS number.
    """
    return self.__as_
      
  def _set_as_(self, v, load=False):
    """
    Setter method for as_, mapped from YANG variable /eid/as_number_lcaf/as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_() directly.

    YANG Description: AS number.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_ must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)""",
        })

    self.__as_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_(self):
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/as_number_lcaf/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/as_number_lcaf/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  as_ = property(_get_as_, _set_as_)
  address = property(_get_address, _set_address)

  __choices__ = {u'address': {u'as-number-lcaf': [u'as_', u'address']}}
  _pyangbind_elements = {'as_': as_, 'address': address, }


class yc_application_data_ietf_lisp_address_types__eid_application_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/application-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Application Data LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__address','__protocol','__ip_tos','__local_port_low','__local_port_high','__remote_port_low','__remote_port_high',)

  _yang_name = 'application-data'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_port_low = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__local_port_low = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    self.__local_port_high = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__ip_tos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ip-tos", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)
    self.__remote_port_high = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'application-data']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/application_data/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/application_data/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /eid/application_data/protocol (uint8)

    YANG Description: Protocol number.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /eid/application_data/protocol (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Protocol number.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_ip_tos(self):
    """
    Getter method for ip_tos, mapped from YANG variable /eid/application_data/ip_tos (int32)

    YANG Description: Type of service field.
    """
    return self.__ip_tos
      
  def _set_ip_tos(self, v, load=False):
    """
    Setter method for ip_tos, mapped from YANG variable /eid/application_data/ip_tos (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_tos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_tos() directly.

    YANG Description: Type of service field.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ip-tos", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_tos must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ip-tos", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)""",
        })

    self.__ip_tos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_tos(self):
    self.__ip_tos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ip-tos", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)


  def _get_local_port_low(self):
    """
    Getter method for local_port_low, mapped from YANG variable /eid/application_data/local_port_low (inet:port-number)

    YANG Description: Low end of local port range.
    """
    return self.__local_port_low
      
  def _set_local_port_low(self, v, load=False):
    """
    Setter method for local_port_low, mapped from YANG variable /eid/application_data/local_port_low (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_port_low is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_port_low() directly.

    YANG Description: Low end of local port range.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_port_low must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)""",
        })

    self.__local_port_low = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_port_low(self):
    self.__local_port_low = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)


  def _get_local_port_high(self):
    """
    Getter method for local_port_high, mapped from YANG variable /eid/application_data/local_port_high (inet:port-number)

    YANG Description: High end of local port range.
    """
    return self.__local_port_high
      
  def _set_local_port_high(self, v, load=False):
    """
    Setter method for local_port_high, mapped from YANG variable /eid/application_data/local_port_high (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_port_high is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_port_high() directly.

    YANG Description: High end of local port range.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_port_high must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)""",
        })

    self.__local_port_high = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_port_high(self):
    self.__local_port_high = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="local-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)


  def _get_remote_port_low(self):
    """
    Getter method for remote_port_low, mapped from YANG variable /eid/application_data/remote_port_low (inet:port-number)

    YANG Description: Low end of remote port range.
    """
    return self.__remote_port_low
      
  def _set_remote_port_low(self, v, load=False):
    """
    Setter method for remote_port_low, mapped from YANG variable /eid/application_data/remote_port_low (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port_low is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port_low() directly.

    YANG Description: Low end of remote port range.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port_low must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)""",
        })

    self.__remote_port_low = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port_low(self):
    self.__remote_port_low = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-low", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)


  def _get_remote_port_high(self):
    """
    Getter method for remote_port_high, mapped from YANG variable /eid/application_data/remote_port_high (inet:port-number)

    YANG Description: High end of remote port range.
    """
    return self.__remote_port_high
      
  def _set_remote_port_high(self, v, load=False):
    """
    Setter method for remote_port_high, mapped from YANG variable /eid/application_data/remote_port_high (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port_high is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port_high() directly.

    YANG Description: High end of remote port range.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port_high must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)""",
        })

    self.__remote_port_high = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port_high(self):
    self.__remote_port_high = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="remote-port-high", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:port-number', is_config=True)

  address = property(_get_address, _set_address)
  protocol = property(_get_protocol, _set_protocol)
  ip_tos = property(_get_ip_tos, _set_ip_tos)
  local_port_low = property(_get_local_port_low, _set_local_port_low)
  local_port_high = property(_get_local_port_high, _set_local_port_high)
  remote_port_low = property(_get_remote_port_low, _set_remote_port_low)
  remote_port_high = property(_get_remote_port_high, _set_remote_port_high)

  __choices__ = {u'address': {u'application-data': [u'address', u'protocol', u'ip_tos', u'local_port_low', u'local_port_high', u'remote_port_low', u'remote_port_high']}}
  _pyangbind_elements = {'address': address, 'protocol': protocol, 'ip_tos': ip_tos, 'local_port_low': local_port_low, 'local_port_high': local_port_high, 'remote_port_low': remote_port_low, 'remote_port_high': remote_port_high, }


class yc_geo_coordinates_ietf_lisp_address_types__eid_geo_coordinates(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/geo-coordinates. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Geo-coordinates LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__latitude_degrees','__latitude_minutes','__latitude_seconds','__longitude_degrees','__longitude_minutes','__longitude_seconds','__altitude','__address',)

  _yang_name = 'geo-coordinates'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__latitude_seconds = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__longitude_minutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__altitude = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="altitude", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)
    self.__latitude_minutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__longitude_seconds = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__latitude_degrees = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0 .. 90']}), is_leaf=True, yang_name="latitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__longitude_degrees = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0 .. 180']}), is_leaf=True, yang_name="longitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'geo-coordinates']

  def _get_latitude_degrees(self):
    """
    Getter method for latitude_degrees, mapped from YANG variable /eid/geo_coordinates/latitude_degrees (uint8)

    YANG Description: Degrees of latitude.
    """
    return self.__latitude_degrees
      
  def _set_latitude_degrees(self, v, load=False):
    """
    Setter method for latitude_degrees, mapped from YANG variable /eid/geo_coordinates/latitude_degrees (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latitude_degrees is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latitude_degrees() directly.

    YANG Description: Degrees of latitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0 .. 90']}), is_leaf=True, yang_name="latitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latitude_degrees must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0 .. 90']}), is_leaf=True, yang_name="latitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__latitude_degrees = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latitude_degrees(self):
    self.__latitude_degrees = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0 .. 90']}), is_leaf=True, yang_name="latitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_latitude_minutes(self):
    """
    Getter method for latitude_minutes, mapped from YANG variable /eid/geo_coordinates/latitude_minutes (uint8)

    YANG Description: Minutes of latitude.
    """
    return self.__latitude_minutes
      
  def _set_latitude_minutes(self, v, load=False):
    """
    Setter method for latitude_minutes, mapped from YANG variable /eid/geo_coordinates/latitude_minutes (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latitude_minutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latitude_minutes() directly.

    YANG Description: Minutes of latitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latitude_minutes must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__latitude_minutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latitude_minutes(self):
    self.__latitude_minutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_latitude_seconds(self):
    """
    Getter method for latitude_seconds, mapped from YANG variable /eid/geo_coordinates/latitude_seconds (uint8)

    YANG Description: Seconds of latitude.
    """
    return self.__latitude_seconds
      
  def _set_latitude_seconds(self, v, load=False):
    """
    Setter method for latitude_seconds, mapped from YANG variable /eid/geo_coordinates/latitude_seconds (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latitude_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latitude_seconds() directly.

    YANG Description: Seconds of latitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latitude_seconds must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__latitude_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latitude_seconds(self):
    self.__latitude_seconds = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="latitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_longitude_degrees(self):
    """
    Getter method for longitude_degrees, mapped from YANG variable /eid/geo_coordinates/longitude_degrees (uint16)

    YANG Description: Degrees of longitude.
    """
    return self.__longitude_degrees
      
  def _set_longitude_degrees(self, v, load=False):
    """
    Setter method for longitude_degrees, mapped from YANG variable /eid/geo_coordinates/longitude_degrees (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_longitude_degrees is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_longitude_degrees() directly.

    YANG Description: Degrees of longitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0 .. 180']}), is_leaf=True, yang_name="longitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """longitude_degrees must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0 .. 180']}), is_leaf=True, yang_name="longitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)""",
        })

    self.__longitude_degrees = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_longitude_degrees(self):
    self.__longitude_degrees = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0 .. 180']}), is_leaf=True, yang_name="longitude-degrees", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)


  def _get_longitude_minutes(self):
    """
    Getter method for longitude_minutes, mapped from YANG variable /eid/geo_coordinates/longitude_minutes (uint8)

    YANG Description: Minutes of longitude.
    """
    return self.__longitude_minutes
      
  def _set_longitude_minutes(self, v, load=False):
    """
    Setter method for longitude_minutes, mapped from YANG variable /eid/geo_coordinates/longitude_minutes (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_longitude_minutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_longitude_minutes() directly.

    YANG Description: Minutes of longitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """longitude_minutes must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__longitude_minutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_longitude_minutes(self):
    self.__longitude_minutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-minutes", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_longitude_seconds(self):
    """
    Getter method for longitude_seconds, mapped from YANG variable /eid/geo_coordinates/longitude_seconds (uint8)

    YANG Description: Seconds of longitude.
    """
    return self.__longitude_seconds
      
  def _set_longitude_seconds(self, v, load=False):
    """
    Setter method for longitude_seconds, mapped from YANG variable /eid/geo_coordinates/longitude_seconds (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_longitude_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_longitude_seconds() directly.

    YANG Description: Seconds of longitude.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """longitude_seconds must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__longitude_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_longitude_seconds(self):
    self.__longitude_seconds = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..59']}), is_leaf=True, yang_name="longitude-seconds", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)


  def _get_altitude(self):
    """
    Getter method for altitude, mapped from YANG variable /eid/geo_coordinates/altitude (int32)

    YANG Description: Height relative to sea level in meters.
    """
    return self.__altitude
      
  def _set_altitude(self, v, load=False):
    """
    Setter method for altitude, mapped from YANG variable /eid/geo_coordinates/altitude (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_altitude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_altitude() directly.

    YANG Description: Height relative to sea level in meters.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="altitude", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """altitude must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="altitude", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)""",
        })

    self.__altitude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_altitude(self):
    self.__altitude = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="altitude", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='int32', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/geo_coordinates/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/geo_coordinates/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  latitude_degrees = property(_get_latitude_degrees, _set_latitude_degrees)
  latitude_minutes = property(_get_latitude_minutes, _set_latitude_minutes)
  latitude_seconds = property(_get_latitude_seconds, _set_latitude_seconds)
  longitude_degrees = property(_get_longitude_degrees, _set_longitude_degrees)
  longitude_minutes = property(_get_longitude_minutes, _set_longitude_minutes)
  longitude_seconds = property(_get_longitude_seconds, _set_longitude_seconds)
  altitude = property(_get_altitude, _set_altitude)
  address = property(_get_address, _set_address)

  __choices__ = {u'address': {u'geo-coordinates': [u'latitude_degrees', u'latitude_minutes', u'latitude_seconds', u'longitude_degrees', u'longitude_minutes', u'longitude_seconds', u'altitude', u'address']}}
  _pyangbind_elements = {'latitude_degrees': latitude_degrees, 'latitude_minutes': latitude_minutes, 'latitude_seconds': latitude_seconds, 'longitude_degrees': longitude_degrees, 'longitude_minutes': longitude_minutes, 'longitude_seconds': longitude_seconds, 'altitude': altitude, 'address': address, }


class yc_nat_traversal_ietf_lisp_address_types__eid_nat_traversal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/nat-traversal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: NAT-Traversal LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ms_udp_port','__etr_udp_port','__global_etr_rloc','__ms_rloc','__private_etr_rloc','__rtr_rlocs',)

  _yang_name = 'nat-traversal'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ms_udp_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ms-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)
    self.__etr_udp_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="etr-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)
    self.__ms_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="ms-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__private_etr_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="private-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__global_etr_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="global-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__rtr_rlocs = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="rtr-rlocs", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'nat-traversal']

  def _get_ms_udp_port(self):
    """
    Getter method for ms_udp_port, mapped from YANG variable /eid/nat_traversal/ms_udp_port (uint16)

    YANG Description: Map-Server UDP port (set to 4342).
    """
    return self.__ms_udp_port
      
  def _set_ms_udp_port(self, v, load=False):
    """
    Setter method for ms_udp_port, mapped from YANG variable /eid/nat_traversal/ms_udp_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ms_udp_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ms_udp_port() directly.

    YANG Description: Map-Server UDP port (set to 4342).
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ms-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ms_udp_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ms-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)""",
        })

    self.__ms_udp_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ms_udp_port(self):
    self.__ms_udp_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ms-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)


  def _get_etr_udp_port(self):
    """
    Getter method for etr_udp_port, mapped from YANG variable /eid/nat_traversal/etr_udp_port (uint16)

    YANG Description: ETR UDP port.
    """
    return self.__etr_udp_port
      
  def _set_etr_udp_port(self, v, load=False):
    """
    Setter method for etr_udp_port, mapped from YANG variable /eid/nat_traversal/etr_udp_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_etr_udp_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_etr_udp_port() directly.

    YANG Description: ETR UDP port.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="etr-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """etr_udp_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="etr-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)""",
        })

    self.__etr_udp_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_etr_udp_port(self):
    self.__etr_udp_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="etr-udp-port", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint16', is_config=True)


  def _get_global_etr_rloc(self):
    """
    Getter method for global_etr_rloc, mapped from YANG variable /eid/nat_traversal/global_etr_rloc (simple-address)

    YANG Description: Global ETR RLOC address.
    """
    return self.__global_etr_rloc
      
  def _set_global_etr_rloc(self, v, load=False):
    """
    Setter method for global_etr_rloc, mapped from YANG variable /eid/nat_traversal/global_etr_rloc (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_etr_rloc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_etr_rloc() directly.

    YANG Description: Global ETR RLOC address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="global-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_etr_rloc must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="global-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__global_etr_rloc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_etr_rloc(self):
    self.__global_etr_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="global-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_ms_rloc(self):
    """
    Getter method for ms_rloc, mapped from YANG variable /eid/nat_traversal/ms_rloc (simple-address)

    YANG Description: Map-Server RLOC address.
    """
    return self.__ms_rloc
      
  def _set_ms_rloc(self, v, load=False):
    """
    Setter method for ms_rloc, mapped from YANG variable /eid/nat_traversal/ms_rloc (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ms_rloc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ms_rloc() directly.

    YANG Description: Map-Server RLOC address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="ms-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ms_rloc must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="ms-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__ms_rloc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ms_rloc(self):
    self.__ms_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="ms-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_private_etr_rloc(self):
    """
    Getter method for private_etr_rloc, mapped from YANG variable /eid/nat_traversal/private_etr_rloc (simple-address)

    YANG Description: Private ETR RLOC address.
    """
    return self.__private_etr_rloc
      
  def _set_private_etr_rloc(self, v, load=False):
    """
    Setter method for private_etr_rloc, mapped from YANG variable /eid/nat_traversal/private_etr_rloc (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_private_etr_rloc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_private_etr_rloc() directly.

    YANG Description: Private ETR RLOC address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="private-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """private_etr_rloc must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="private-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__private_etr_rloc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_private_etr_rloc(self):
    self.__private_etr_rloc = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="private-etr-rloc", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_rtr_rlocs(self):
    """
    Getter method for rtr_rlocs, mapped from YANG variable /eid/nat_traversal/rtr_rlocs (simple-address)

    YANG Description: List of RTR RLOC addresses.
    """
    return self.__rtr_rlocs
      
  def _set_rtr_rlocs(self, v, load=False):
    """
    Setter method for rtr_rlocs, mapped from YANG variable /eid/nat_traversal/rtr_rlocs (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rtr_rlocs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rtr_rlocs() directly.

    YANG Description: List of RTR RLOC addresses.
    """
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="rtr-rlocs", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rtr_rlocs must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="rtr-rlocs", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__rtr_rlocs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rtr_rlocs(self):
    self.__rtr_rlocs = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),]), is_leaf=False, yang_name="rtr-rlocs", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  ms_udp_port = property(_get_ms_udp_port, _set_ms_udp_port)
  etr_udp_port = property(_get_etr_udp_port, _set_etr_udp_port)
  global_etr_rloc = property(_get_global_etr_rloc, _set_global_etr_rloc)
  ms_rloc = property(_get_ms_rloc, _set_ms_rloc)
  private_etr_rloc = property(_get_private_etr_rloc, _set_private_etr_rloc)
  rtr_rlocs = property(_get_rtr_rlocs, _set_rtr_rlocs)

  __choices__ = {u'address': {u'nat-traversal': [u'ms_udp_port', u'etr_udp_port', u'global_etr_rloc', u'ms_rloc', u'private_etr_rloc', u'rtr_rlocs']}}
  _pyangbind_elements = {'ms_udp_port': ms_udp_port, 'etr_udp_port': etr_udp_port, 'global_etr_rloc': global_etr_rloc, 'ms_rloc': ms_rloc, 'private_etr_rloc': private_etr_rloc, 'rtr_rlocs': rtr_rlocs, }


class yc_hop_ietf_lisp_address_types__eid_explicit_locator_path_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/explicit-locator-path/hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of locator hops forming the explicit path.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__hop_id','__address',)

  _yang_name = 'hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hop_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="hop-id", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='string', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'explicit-locator-path', u'hop']

  def _get_hop_id(self):
    """
    Getter method for hop_id, mapped from YANG variable /eid/explicit_locator_path/hop/hop_id (string)

    YANG Description: Unique identifier for the hop.
    """
    return self.__hop_id
      
  def _set_hop_id(self, v, load=False):
    """
    Setter method for hop_id, mapped from YANG variable /eid/explicit_locator_path/hop/hop_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop_id() directly.

    YANG Description: Unique identifier for the hop.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="hop-id", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hop_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="hop-id", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='string', is_config=True)""",
        })

    self.__hop_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop_id(self):
    self.__hop_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="hop-id", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /eid/explicit_locator_path/hop/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /eid/explicit_locator_path/hop/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="address", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  hop_id = property(_get_hop_id, _set_hop_id)
  address = property(_get_address, _set_address)

  __choices__ = {u'address': {u'explicit-locator-path': [u'hop_id', u'address']}}
  _pyangbind_elements = {'hop_id': hop_id, 'address': address, }


class yc_explicit_locator_path_ietf_lisp_address_types__eid_explicit_locator_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/explicit-locator-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Explicit Locator Path LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__hop',)

  _yang_name = 'explicit-locator-path'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hop = YANGDynClass(base=YANGListType("hop_id",yc_hop_ietf_lisp_address_types__eid_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='hop-id', choice=(u'address', u'explicit-locator-path')), is_container='list', yang_name="hop", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'explicit-locator-path']

  def _get_hop(self):
    """
    Getter method for hop, mapped from YANG variable /eid/explicit_locator_path/hop (list)

    YANG Description: List of locator hops forming the explicit path.
    """
    return self.__hop
      
  def _set_hop(self, v, load=False):
    """
    Setter method for hop, mapped from YANG variable /eid/explicit_locator_path/hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop() directly.

    YANG Description: List of locator hops forming the explicit path.
    """
    try:
      t = YANGDynClass(v,base=YANGListType("hop_id",yc_hop_ietf_lisp_address_types__eid_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='hop-id', choice=(u'address', u'explicit-locator-path')), is_container='list', yang_name="hop", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("hop_id",yc_hop_ietf_lisp_address_types__eid_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='hop-id', choice=(u'address', u'explicit-locator-path')), is_container='list', yang_name="hop", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='list', is_config=True)""",
        })

    self.__hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop(self):
    self.__hop = YANGDynClass(base=YANGListType("hop_id",yc_hop_ietf_lisp_address_types__eid_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='hop-id', choice=(u'address', u'explicit-locator-path')), is_container='list', yang_name="hop", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='list', is_config=True)

  hop = property(_get_hop, _set_hop)

  __choices__ = {u'address': {u'explicit-locator-path': [u'hop']}}
  _pyangbind_elements = {'hop': hop, }


class yc_source_dest_key_ietf_lisp_address_types__eid_source_dest_key(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/source-dest-key. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Source/Dest LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__source','__dest',)

  _yang_name = 'source-dest-key'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dest = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="dest", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__source = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="source", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'source-dest-key']

  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /eid/source_dest_key/source (simple-address)

    YANG Description: Source address.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /eid/source_dest_key/source (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Source address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="source", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="source", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="source", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_dest(self):
    """
    Getter method for dest, mapped from YANG variable /eid/source_dest_key/dest (simple-address)

    YANG Description: Destination address.
    """
    return self.__dest
      
  def _set_dest(self, v, load=False):
    """
    Setter method for dest, mapped from YANG variable /eid/source_dest_key/dest (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest() directly.

    YANG Description: Destination address.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="dest", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="dest", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest(self):
    self.__dest = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="dest", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  source = property(_get_source, _set_source)
  dest = property(_get_dest, _set_dest)

  __choices__ = {u'address': {u'source-dest-key': [u'source', u'dest']}}
  _pyangbind_elements = {'source': source, 'dest': dest, }


class yc_key_value_address_ietf_lisp_address_types__eid_key_value_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/key-value-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Key/Value Address LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__key','__value',)

  _yang_name = 'key-value-address'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="value", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    self.__key = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="key", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'key-value-address']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /eid/key_value_address/key (simple-address)

    YANG Description: Address as Key.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /eid/key_value_address/key (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Address as Key.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="key", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="key", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="key", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /eid/key_value_address/value (simple-address)

    YANG Description: Address as Value.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /eid/key_value_address/value (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Address as Value.
    """
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="value", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with simple-address""",
          'defined-type': "ietf-lisp-address-types:simple-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="value", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}),unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="value", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='simple-address', is_config=True)

  key = property(_get_key, _set_key)
  value = property(_get_value, _set_value)

  __choices__ = {u'address': {u'key-value-address': [u'key', u'value']}}
  _pyangbind_elements = {'key': key, 'value': value, }


class yc_service_path_ietf_lisp_address_types__eid_service_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid/service-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service Path LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__service_path_id','__service_index',)

  _yang_name = 'service-path'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__service_path_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="service-path-id", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='service-path-id-type', is_config=True)
    self.__service_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="service-index", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid', u'service-path']

  def _get_service_path_id(self):
    """
    Getter method for service_path_id, mapped from YANG variable /eid/service_path/service_path_id (service-path-id-type)

    YANG Description: Service path identifier for the path for NSH header
    """
    return self.__service_path_id
      
  def _set_service_path_id(self, v, load=False):
    """
    Setter method for service_path_id, mapped from YANG variable /eid/service_path/service_path_id (service-path-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_path_id() directly.

    YANG Description: Service path identifier for the path for NSH header
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="service-path-id", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='service-path-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_path_id must be of a type compatible with service-path-id-type""",
          'defined-type': "ietf-lisp-address-types:service-path-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="service-path-id", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='service-path-id-type', is_config=True)""",
        })

    self.__service_path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_path_id(self):
    self.__service_path_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="service-path-id", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='service-path-id-type', is_config=True)


  def _get_service_index(self):
    """
    Getter method for service_index, mapped from YANG variable /eid/service_path/service_index (uint8)

    YANG Description: Service path index for NSH header
    """
    return self.__service_index
      
  def _set_service_index(self, v, load=False):
    """
    Setter method for service_index, mapped from YANG variable /eid/service_path/service_index (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_index() directly.

    YANG Description: Service path index for NSH header
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="service-index", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_index must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="service-index", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)""",
        })

    self.__service_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_index(self):
    self.__service_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="service-index", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='uint8', is_config=True)

  service_path_id = property(_get_service_path_id, _set_service_path_id)
  service_index = property(_get_service_index, _set_service_index)

  __choices__ = {u'address': {u'service-path': [u'service_path_id', u'service_index']}}
  _pyangbind_elements = {'service_path_id': service_path_id, 'service_index': service_index, }


class yc_eid_ietf_lisp_address_types__eid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /eid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__address_type','__virtual_network_id','__no_address','__ipv4','__ipv4_prefix','__ipv6','__ipv6_prefix','__mac','__distinguished_name','__as_number','__null_address','__afi_list','__instance_id','__as_number_lcaf','__application_data','__geo_coordinates','__nat_traversal','__explicit_locator_path','__source_dest_key','__key_value_address','__service_path',)

  _yang_name = 'eid'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__as_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as-number", parent=self, choice=(u'address', u'as-number'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)
    self.__as_number_lcaf = YANGDynClass(base=yc_as_number_lcaf_ietf_lisp_address_types__eid_as_number_lcaf, is_container='container', yang_name="as-number-lcaf", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__null_address = YANGDynClass(base=yc_null_address_ietf_lisp_address_types__eid_null_address, is_container='container', yang_name="null-address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__key_value_address = YANGDynClass(base=yc_key_value_address_ietf_lisp_address_types__eid_key_value_address, is_container='container', yang_name="key-value-address", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__distinguished_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="distinguished-name", parent=self, choice=(u'address', u'distinguished-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='distinguished-name-type', is_config=True)
    self.__source_dest_key = YANGDynClass(base=yc_source_dest_key_ietf_lisp_address_types__eid_source_dest_key, is_container='container', yang_name="source-dest-key", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__no_address = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-address", parent=self, choice=(u'address', u'no-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)
    self.__ipv4_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, choice=(u'address', u'ipv4-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-prefix', is_config=True)
    self.__virtual_network_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="virtual-network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)
    self.__explicit_locator_path = YANGDynClass(base=yc_explicit_locator_path_ietf_lisp_address_types__eid_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__service_path = YANGDynClass(base=yc_service_path_ietf_lisp_address_types__eid_service_path, is_container='container', yang_name="service-path", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__instance_id = YANGDynClass(base=yc_instance_id_ietf_lisp_address_types__eid_instance_id, is_container='container', yang_name="instance-id", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, choice=(u'address', u'mac'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='yang:mac-address', is_config=True)
    self.__geo_coordinates = YANGDynClass(base=yc_geo_coordinates_ietf_lisp_address_types__eid_geo_coordinates, is_container='container', yang_name="geo-coordinates", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4", parent=self, choice=(u'address', u'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-address', is_config=True)
    self.__application_data = YANGDynClass(base=yc_application_data_ietf_lisp_address_types__eid_application_data, is_container='container', yang_name="application-data", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6", parent=self, choice=(u'address', u'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-address', is_config=True)
    self.__ipv6_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, choice=(u'address', u'ipv6-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-prefix', is_config=True)
    self.__nat_traversal = YANGDynClass(base=yc_nat_traversal_ietf_lisp_address_types__eid_nat_traversal, is_container='container', yang_name="nat-traversal", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    self.__address_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'geo-coordinates-lcaf': {}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'nonce-locator-lcaf': {}, u'lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {}, u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='lisp-address-family-ref', is_config=True)
    self.__afi_list = YANGDynClass(base=yc_afi_list_ietf_lisp_address_types__eid_afi_list, is_container='container', yang_name="afi-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'eid']

  def _get_address_type(self):
    """
    Getter method for address_type, mapped from YANG variable /eid/address_type (lisp-address-family-ref)

    YANG Description: Type of the LISP address.
    """
    return self.__address_type
      
  def _set_address_type(self, v, load=False):
    """
    Setter method for address_type, mapped from YANG variable /eid/address_type (lisp-address-family-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_type() directly.

    YANG Description: Type of the LISP address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'geo-coordinates-lcaf': {}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'nonce-locator-lcaf': {}, u'lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {}, u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='lisp-address-family-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_type must be of a type compatible with lisp-address-family-ref""",
          'defined-type': "ietf-lisp-address-types:lisp-address-family-ref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'geo-coordinates-lcaf': {}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'nonce-locator-lcaf': {}, u'lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {}, u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='lisp-address-family-ref', is_config=True)""",
        })

    self.__address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_type(self):
    self.__address_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'geo-coordinates-lcaf': {}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'nonce-locator-lcaf': {}, u'lcaf': {u'geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:instance-id-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@module': u'ietf-lisp-address-types', u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}}, u'null-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:afi-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'no-address-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:application-data-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:encapsulation-format-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'multicast-info-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'security-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv4-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:explicit-locator-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'afi-list-lcaf': {}, u'laddr:nonce-locator-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'distinguished-name-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'application-data-lcaf': {}, u'json-data-model-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:ipv6-prefix-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:geo-coordinates-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:service-path-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:as-number-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'mac-afi': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:nat-traversal-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'service-path-lcaf': {}, u'laddr:opaque-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:replication-list-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:key-value-address-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}, u'laddr:source-dest-key-lcaf': {'@module': u'ietf-lisp-address-types', '@namespace': u'urn:ietf:params:xml:ns:yang:ietf-lisp-address-types'}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='lisp-address-family-ref', is_config=True)


  def _get_virtual_network_id(self):
    """
    Getter method for virtual_network_id, mapped from YANG variable /eid/virtual_network_id (instance-id-type)

    YANG Description: Virtual Network Identifier (instance-id) of the address.
    """
    return self.__virtual_network_id
      
  def _set_virtual_network_id(self, v, load=False):
    """
    Setter method for virtual_network_id, mapped from YANG variable /eid/virtual_network_id (instance-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_id() directly.

    YANG Description: Virtual Network Identifier (instance-id) of the address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="virtual-network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_network_id must be of a type compatible with instance-id-type""",
          'defined-type': "ietf-lisp-address-types:instance-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="virtual-network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)""",
        })

    self.__virtual_network_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_network_id(self):
    self.__virtual_network_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..16777215']}), is_leaf=True, yang_name="virtual-network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='instance-id-type', is_config=True)


  def _get_no_address(self):
    """
    Getter method for no_address, mapped from YANG variable /eid/no_address (empty)

    YANG Description: No address.
    """
    return self.__no_address
      
  def _set_no_address(self, v, load=False):
    """
    Setter method for no_address, mapped from YANG variable /eid/no_address (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_address() directly.

    YANG Description: No address.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-address", parent=self, choice=(u'address', u'no-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_address must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-address", parent=self, choice=(u'address', u'no-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)""",
        })

    self.__no_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_address(self):
    self.__no_address = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-address", parent=self, choice=(u'address', u'no-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='empty', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /eid/ipv4 (inet:ipv4-address)

    YANG Description: IPv4 address.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /eid/ipv4 (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: IPv4 address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4", parent=self, choice=(u'address', u'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4", parent=self, choice=(u'address', u'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4", parent=self, choice=(u'address', u'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-address', is_config=True)


  def _get_ipv4_prefix(self):
    """
    Getter method for ipv4_prefix, mapped from YANG variable /eid/ipv4_prefix (inet:ipv4-prefix)

    YANG Description: IPv4 prefix.
    """
    return self.__ipv4_prefix
      
  def _set_ipv4_prefix(self, v, load=False):
    """
    Setter method for ipv4_prefix, mapped from YANG variable /eid/ipv4_prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_prefix() directly.

    YANG Description: IPv4 prefix.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, choice=(u'address', u'ipv4-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, choice=(u'address', u'ipv4-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-prefix', is_config=True)""",
        })

    self.__ipv4_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_prefix(self):
    self.__ipv4_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, choice=(u'address', u'ipv4-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv4-prefix', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /eid/ipv6 (inet:ipv6-address)

    YANG Description: IPv6 address.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /eid/ipv6 (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: IPv6 address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6", parent=self, choice=(u'address', u'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6", parent=self, choice=(u'address', u'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6", parent=self, choice=(u'address', u'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-address', is_config=True)


  def _get_ipv6_prefix(self):
    """
    Getter method for ipv6_prefix, mapped from YANG variable /eid/ipv6_prefix (inet:ipv6-prefix)

    YANG Description: IPv6 address.
    """
    return self.__ipv6_prefix
      
  def _set_ipv6_prefix(self, v, load=False):
    """
    Setter method for ipv6_prefix, mapped from YANG variable /eid/ipv6_prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_prefix() directly.

    YANG Description: IPv6 address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, choice=(u'address', u'ipv6-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, choice=(u'address', u'ipv6-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-prefix', is_config=True)""",
        })

    self.__ipv6_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_prefix(self):
    self.__ipv6_prefix = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, choice=(u'address', u'ipv6-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:ipv6-prefix', is_config=True)


  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /eid/mac (yang:mac-address)

    YANG Description: MAC address.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /eid/mac (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, choice=(u'address', u'mac'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, choice=(u'address', u'mac'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, choice=(u'address', u'mac'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='yang:mac-address', is_config=True)


  def _get_distinguished_name(self):
    """
    Getter method for distinguished_name, mapped from YANG variable /eid/distinguished_name (distinguished-name-type)

    YANG Description: Distinguished Name address.
    """
    return self.__distinguished_name
      
  def _set_distinguished_name(self, v, load=False):
    """
    Setter method for distinguished_name, mapped from YANG variable /eid/distinguished_name (distinguished-name-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distinguished_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distinguished_name() directly.

    YANG Description: Distinguished Name address.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="distinguished-name", parent=self, choice=(u'address', u'distinguished-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='distinguished-name-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distinguished_name must be of a type compatible with distinguished-name-type""",
          'defined-type': "ietf-lisp-address-types:distinguished-name-type",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="distinguished-name", parent=self, choice=(u'address', u'distinguished-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='distinguished-name-type', is_config=True)""",
        })

    self.__distinguished_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distinguished_name(self):
    self.__distinguished_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="distinguished-name", parent=self, choice=(u'address', u'distinguished-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='distinguished-name-type', is_config=True)


  def _get_as_number(self):
    """
    Getter method for as_number, mapped from YANG variable /eid/as_number (inet:as-number)

    YANG Description: AS Number.
    """
    return self.__as_number
      
  def _set_as_number(self, v, load=False):
    """
    Setter method for as_number, mapped from YANG variable /eid/as_number (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_number() directly.

    YANG Description: AS Number.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as-number", parent=self, choice=(u'address', u'as-number'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_number must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as-number", parent=self, choice=(u'address', u'as-number'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)""",
        })

    self.__as_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_number(self):
    self.__as_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as-number", parent=self, choice=(u'address', u'as-number'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='inet:as-number', is_config=True)


  def _get_null_address(self):
    """
    Getter method for null_address, mapped from YANG variable /eid/null_address (container)

    YANG Description: Null body LCAF type
    """
    return self.__null_address
      
  def _set_null_address(self, v, load=False):
    """
    Setter method for null_address, mapped from YANG variable /eid/null_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_null_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_null_address() directly.

    YANG Description: Null body LCAF type
    """
    try:
      t = YANGDynClass(v,base=yc_null_address_ietf_lisp_address_types__eid_null_address, is_container='container', yang_name="null-address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """null_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_null_address_ietf_lisp_address_types__eid_null_address, is_container='container', yang_name="null-address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__null_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_null_address(self):
    self.__null_address = YANGDynClass(base=yc_null_address_ietf_lisp_address_types__eid_null_address, is_container='container', yang_name="null-address", parent=self, choice=(u'address', u'null-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_afi_list(self):
    """
    Getter method for afi_list, mapped from YANG variable /eid/afi_list (container)

    YANG Description: AFI-List LCAF type.
    """
    return self.__afi_list
      
  def _set_afi_list(self, v, load=False):
    """
    Setter method for afi_list, mapped from YANG variable /eid/afi_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_list() directly.

    YANG Description: AFI-List LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_afi_list_ietf_lisp_address_types__eid_afi_list, is_container='container', yang_name="afi-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afi_list_ietf_lisp_address_types__eid_afi_list, is_container='container', yang_name="afi-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__afi_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_list(self):
    self.__afi_list = YANGDynClass(base=yc_afi_list_ietf_lisp_address_types__eid_afi_list, is_container='container', yang_name="afi-list", parent=self, choice=(u'address', u'afi-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_instance_id(self):
    """
    Getter method for instance_id, mapped from YANG variable /eid/instance_id (container)

    YANG Description: Instance ID LCAF type.
    """
    return self.__instance_id
      
  def _set_instance_id(self, v, load=False):
    """
    Setter method for instance_id, mapped from YANG variable /eid/instance_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance_id() directly.

    YANG Description: Instance ID LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_instance_id_ietf_lisp_address_types__eid_instance_id, is_container='container', yang_name="instance-id", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instance_id_ietf_lisp_address_types__eid_instance_id, is_container='container', yang_name="instance-id", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__instance_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance_id(self):
    self.__instance_id = YANGDynClass(base=yc_instance_id_ietf_lisp_address_types__eid_instance_id, is_container='container', yang_name="instance-id", parent=self, choice=(u'address', u'instance-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_as_number_lcaf(self):
    """
    Getter method for as_number_lcaf, mapped from YANG variable /eid/as_number_lcaf (container)

    YANG Description: AS Number LCAF type.
    """
    return self.__as_number_lcaf
      
  def _set_as_number_lcaf(self, v, load=False):
    """
    Setter method for as_number_lcaf, mapped from YANG variable /eid/as_number_lcaf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_number_lcaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_number_lcaf() directly.

    YANG Description: AS Number LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_as_number_lcaf_ietf_lisp_address_types__eid_as_number_lcaf, is_container='container', yang_name="as-number-lcaf", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_number_lcaf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as_number_lcaf_ietf_lisp_address_types__eid_as_number_lcaf, is_container='container', yang_name="as-number-lcaf", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__as_number_lcaf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_number_lcaf(self):
    self.__as_number_lcaf = YANGDynClass(base=yc_as_number_lcaf_ietf_lisp_address_types__eid_as_number_lcaf, is_container='container', yang_name="as-number-lcaf", parent=self, choice=(u'address', u'as-number-lcaf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_application_data(self):
    """
    Getter method for application_data, mapped from YANG variable /eid/application_data (container)

    YANG Description: Application Data LCAF type.
    """
    return self.__application_data
      
  def _set_application_data(self, v, load=False):
    """
    Setter method for application_data, mapped from YANG variable /eid/application_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_application_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_application_data() directly.

    YANG Description: Application Data LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_application_data_ietf_lisp_address_types__eid_application_data, is_container='container', yang_name="application-data", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """application_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_application_data_ietf_lisp_address_types__eid_application_data, is_container='container', yang_name="application-data", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__application_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_application_data(self):
    self.__application_data = YANGDynClass(base=yc_application_data_ietf_lisp_address_types__eid_application_data, is_container='container', yang_name="application-data", parent=self, choice=(u'address', u'application-data'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_geo_coordinates(self):
    """
    Getter method for geo_coordinates, mapped from YANG variable /eid/geo_coordinates (container)

    YANG Description: Geo-coordinates LCAF type.
    """
    return self.__geo_coordinates
      
  def _set_geo_coordinates(self, v, load=False):
    """
    Setter method for geo_coordinates, mapped from YANG variable /eid/geo_coordinates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geo_coordinates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geo_coordinates() directly.

    YANG Description: Geo-coordinates LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_geo_coordinates_ietf_lisp_address_types__eid_geo_coordinates, is_container='container', yang_name="geo-coordinates", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geo_coordinates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_geo_coordinates_ietf_lisp_address_types__eid_geo_coordinates, is_container='container', yang_name="geo-coordinates", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__geo_coordinates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geo_coordinates(self):
    self.__geo_coordinates = YANGDynClass(base=yc_geo_coordinates_ietf_lisp_address_types__eid_geo_coordinates, is_container='container', yang_name="geo-coordinates", parent=self, choice=(u'address', u'geo-coordinates'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_nat_traversal(self):
    """
    Getter method for nat_traversal, mapped from YANG variable /eid/nat_traversal (container)

    YANG Description: NAT-Traversal LCAF type.
    """
    return self.__nat_traversal
      
  def _set_nat_traversal(self, v, load=False):
    """
    Setter method for nat_traversal, mapped from YANG variable /eid/nat_traversal (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_traversal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_traversal() directly.

    YANG Description: NAT-Traversal LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_nat_traversal_ietf_lisp_address_types__eid_nat_traversal, is_container='container', yang_name="nat-traversal", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_traversal must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nat_traversal_ietf_lisp_address_types__eid_nat_traversal, is_container='container', yang_name="nat-traversal", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__nat_traversal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_traversal(self):
    self.__nat_traversal = YANGDynClass(base=yc_nat_traversal_ietf_lisp_address_types__eid_nat_traversal, is_container='container', yang_name="nat-traversal", parent=self, choice=(u'address', u'nat-traversal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_explicit_locator_path(self):
    """
    Getter method for explicit_locator_path, mapped from YANG variable /eid/explicit_locator_path (container)

    YANG Description: Explicit Locator Path LCAF type.
    """
    return self.__explicit_locator_path
      
  def _set_explicit_locator_path(self, v, load=False):
    """
    Setter method for explicit_locator_path, mapped from YANG variable /eid/explicit_locator_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_explicit_locator_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_explicit_locator_path() directly.

    YANG Description: Explicit Locator Path LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_explicit_locator_path_ietf_lisp_address_types__eid_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """explicit_locator_path must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_explicit_locator_path_ietf_lisp_address_types__eid_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__explicit_locator_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_explicit_locator_path(self):
    self.__explicit_locator_path = YANGDynClass(base=yc_explicit_locator_path_ietf_lisp_address_types__eid_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, choice=(u'address', u'explicit-locator-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_source_dest_key(self):
    """
    Getter method for source_dest_key, mapped from YANG variable /eid/source_dest_key (container)

    YANG Description: Source/Dest LCAF type.
    """
    return self.__source_dest_key
      
  def _set_source_dest_key(self, v, load=False):
    """
    Setter method for source_dest_key, mapped from YANG variable /eid/source_dest_key (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_dest_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_dest_key() directly.

    YANG Description: Source/Dest LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_source_dest_key_ietf_lisp_address_types__eid_source_dest_key, is_container='container', yang_name="source-dest-key", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_dest_key must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_dest_key_ietf_lisp_address_types__eid_source_dest_key, is_container='container', yang_name="source-dest-key", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__source_dest_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_dest_key(self):
    self.__source_dest_key = YANGDynClass(base=yc_source_dest_key_ietf_lisp_address_types__eid_source_dest_key, is_container='container', yang_name="source-dest-key", parent=self, choice=(u'address', u'source-dest-key'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_key_value_address(self):
    """
    Getter method for key_value_address, mapped from YANG variable /eid/key_value_address (container)

    YANG Description: Key/Value Address LCAF type.
    """
    return self.__key_value_address
      
  def _set_key_value_address(self, v, load=False):
    """
    Setter method for key_value_address, mapped from YANG variable /eid/key_value_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_value_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_value_address() directly.

    YANG Description: Key/Value Address LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_key_value_address_ietf_lisp_address_types__eid_key_value_address, is_container='container', yang_name="key-value-address", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_value_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_key_value_address_ietf_lisp_address_types__eid_key_value_address, is_container='container', yang_name="key-value-address", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__key_value_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_value_address(self):
    self.__key_value_address = YANGDynClass(base=yc_key_value_address_ietf_lisp_address_types__eid_key_value_address, is_container='container', yang_name="key-value-address", parent=self, choice=(u'address', u'key-value-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)


  def _get_service_path(self):
    """
    Getter method for service_path, mapped from YANG variable /eid/service_path (container)

    YANG Description: Service Path LCAF type.
    """
    return self.__service_path
      
  def _set_service_path(self, v, load=False):
    """
    Setter method for service_path, mapped from YANG variable /eid/service_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_path() directly.

    YANG Description: Service Path LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_service_path_ietf_lisp_address_types__eid_service_path, is_container='container', yang_name="service-path", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_path must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_service_path_ietf_lisp_address_types__eid_service_path, is_container='container', yang_name="service-path", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__service_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_path(self):
    self.__service_path = YANGDynClass(base=yc_service_path_ietf_lisp_address_types__eid_service_path, is_container='container', yang_name="service-path", parent=self, choice=(u'address', u'service-path'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)

  address_type = property(_get_address_type, _set_address_type)
  virtual_network_id = property(_get_virtual_network_id, _set_virtual_network_id)
  no_address = property(_get_no_address, _set_no_address)
  ipv4 = property(_get_ipv4, _set_ipv4)
  ipv4_prefix = property(_get_ipv4_prefix, _set_ipv4_prefix)
  ipv6 = property(_get_ipv6, _set_ipv6)
  ipv6_prefix = property(_get_ipv6_prefix, _set_ipv6_prefix)
  mac = property(_get_mac, _set_mac)
  distinguished_name = property(_get_distinguished_name, _set_distinguished_name)
  as_number = property(_get_as_number, _set_as_number)
  null_address = property(_get_null_address, _set_null_address)
  afi_list = property(_get_afi_list, _set_afi_list)
  instance_id = property(_get_instance_id, _set_instance_id)
  as_number_lcaf = property(_get_as_number_lcaf, _set_as_number_lcaf)
  application_data = property(_get_application_data, _set_application_data)
  geo_coordinates = property(_get_geo_coordinates, _set_geo_coordinates)
  nat_traversal = property(_get_nat_traversal, _set_nat_traversal)
  explicit_locator_path = property(_get_explicit_locator_path, _set_explicit_locator_path)
  source_dest_key = property(_get_source_dest_key, _set_source_dest_key)
  key_value_address = property(_get_key_value_address, _set_key_value_address)
  service_path = property(_get_service_path, _set_service_path)

  __choices__ = {u'address': {u'no-address': [u'no_address'], u'ipv4-prefix': [u'ipv4_prefix'], u'explicit-locator-path': [u'explicit_locator_path'], u'ipv6-prefix': [u'ipv6_prefix'], u'key-value-address': [u'key_value_address'], u'nat-traversal': [u'nat_traversal'], u'afi-list': [u'afi_list'], u'as-number': [u'as_number'], u'null-address': [u'null_address'], u'distinguished-name': [u'distinguished_name'], u'as-number-lcaf': [u'as_number_lcaf'], u'source-dest-key': [u'source_dest_key'], u'mac': [u'mac'], u'application-data': [u'application_data'], u'ipv4': [u'ipv4'], u'ipv6': [u'ipv6'], u'geo-coordinates': [u'geo_coordinates'], u'service-path': [u'service_path'], u'instance-id': [u'instance_id']}}
  _pyangbind_elements = {'address_type': address_type, 'virtual_network_id': virtual_network_id, 'no_address': no_address, 'ipv4': ipv4, 'ipv4_prefix': ipv4_prefix, 'ipv6': ipv6, 'ipv6_prefix': ipv6_prefix, 'mac': mac, 'distinguished_name': distinguished_name, 'as_number': as_number, 'null_address': null_address, 'afi_list': afi_list, 'instance_id': instance_id, 'as_number_lcaf': as_number_lcaf, 'application_data': application_data, 'geo_coordinates': geo_coordinates, 'nat_traversal': nat_traversal, 'explicit_locator_path': explicit_locator_path, 'source_dest_key': source_dest_key, 'key_value_address': key_value_address, 'service_path': service_path, }


class ietf_lisp_address_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-lisp-address-types - based on the path /ietf-lisp-address-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines the LISP Canonical Address Formats
(LCAF) for LISP. The module can be extended by vendors to
define vendor-specific parameters.

Copyright (c) 2014 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6338; see
the RFC itself for full legal notices.


  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__eid',)

  _yang_name = 'ietf-lisp-address-types'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__eid = YANGDynClass(base=yc_eid_ietf_lisp_address_types__eid, is_container='container', yang_name="eid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_eid(self):
    """
    Getter method for eid, mapped from YANG variable /eid (container)
    """
    return self.__eid
      
  def _set_eid(self, v, load=False):
    """
    Setter method for eid, mapped from YANG variable /eid (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eid() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_eid_ietf_lisp_address_types__eid, is_container='container', yang_name="eid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eid must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_eid_ietf_lisp_address_types__eid, is_container='container', yang_name="eid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)""",
        })

    self.__eid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eid(self):
    self.__eid = YANGDynClass(base=yc_eid_ietf_lisp_address_types__eid, is_container='container', yang_name="eid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-lisp-address-types', defining_module='ietf-lisp-address-types', yang_type='container', is_config=True)

  eid = property(_get_eid, _set_eid)


  _pyangbind_elements = {'eid': eid, }


