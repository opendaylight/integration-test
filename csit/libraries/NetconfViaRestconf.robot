*** Settings ***
Documentation     Access Netconf via Restconf.
...
...               Copyright (c) 2015 Cisco Systems, Inc. and others. All rights reserved.
...
...               This program and the accompanying materials are made available under the
...               terms of the Eclipse Public License v1.0 which accompanies this distribution,
...               and is available at http://www.eclipse.org/legal/epl-v10.html
Library           RequestsLibrary
Library           OperatingSystem

*** Variables ***
@{allowed_status_codes}    ${200}    ${201}    ${204}    # List of integers, not strings. Used by both PUT and DELETE.

*** Keywords ***
FIXME__POLISH_THIS
    # The following code has a bunch of problems which are very hard to fix in
    # terms of debugging and review times. Therefore I propose to merge this test
    # first "as is" and solve the problems of this code in later commits. These
    # problems were identified so far:
    #
    # - Code duplication. The following code is almost identical to what is
    #    present in ConfigViaRestconf.robot. Fixing this means refactoring
    #    ConfigViaRestconf.robot to use this library instead of doing
    #    everything on its own.
    # - The interface of this code might be too optimized for the needs of
    #    one test suite. Maybe it should be generalized.
    # - The Teardown_Netconf_Via_Restconf seems to be incomplete. It is
    #    supposed to close the session but (as the code suggests in a
    #    comment), the functionality needed is not implemented.
    #
    # Issues identified when trying to make this a library:
    #
    # - A better name might be necessary (this actually allows not only
    #    netconf to be accessed but other restconf accessible subsystems as
    #    well).
    # - The ConfigViaRestconf might need to be merged with this code to avoid
    #    strange name clashes when using both in a suite.

Setup_Netconf_Via_Restconf
    [Documentation]    Creates Requests session to be used by subsequent keywords.
    # Do not append slash at the end uf URL, Requests would add another, resulting in error.
    Create_NVR_Session    nvr_session    ${ODL_SYSTEM_IP}
    BuiltIn.Set_Suite_Variable    ${NetconfViaRestconf__active_session}    nvr_session

Teardown_Netconf_Via_Restconf
    [Documentation]    Teardown to pair with Setup (otherwise no-op).
    BuiltIn.Comment    TODO: The following line does not seem to be implemented by RequestsLibrary. Look for a workaround.
    BuiltIn.Comment    Delete_Session    nvr_session

Resolve_URI_From_Template_Folder
    [Arguments]    ${folder}    ${mapping_as_string}
    [Documentation]    Read URI template from folder, strip endline, make changes according to mapping, return the result.
    ${uri_template}=    OperatingSystem.Get_File    ${folder}${/}config.uri
    BuiltIn.Log    ${uri_template}
    ${uri_part}=    Strip_Endline_And_Apply_Substitutions_From_Mapping    ${uri_template}    ${mapping_as_string}
    [Return]    ${uri_part}

Resolve_Xml_Data_From_Template_Folder
    [Arguments]    ${folder}    ${mapping_as_string}
    [Documentation]    Read data template from folder, strip endline, make changes according to mapping, return the result.
    ${data_template}=    OperatingSystem.Get_File    ${folder}${/}data.xml
    BuiltIn.Log    ${data_template}
    ${xml_data}=    Strip_Endline_And_Apply_Substitutions_From_Mapping    ${data_template}    ${mapping_as_string}
    [Return]    ${xml_data}

Strip_Endline_And_Apply_Substitutions_From_Mapping
    [Arguments]    ${template_as_string}    ${mapping_as_string}
    [Documentation]    Strip endline, apply substitutions, Log and return the result.
    # Robot Framework does not understand dictionaries well, so resort to Evaluate.
    # Needs python module "string", and since the template string is expected to contain newline, it has to be enclosed in triple quotes.
    # Using rstrip() removes all trailing whitespace, which is what we want if there is something more than an endline.
    ${final_text}=    BuiltIn.Evaluate    string.Template('''${template_as_string}'''.rstrip()).substitute(${mapping_as_string})    modules=string
    BuiltIn.Log    ${final_text}
    [Return]    ${final_text}

Post_Xml_Via_Restconf
    [Arguments]    ${uri_part}    ${xml_data}
    [Documentation]    Post XML data to given controller-config URI, check reponse text is empty and status_code is 204.
    BuiltIn.Log    ${uri_part}
    BuiltIn.Log    ${xml_data}
    # As seen in previous two Keywords, Post does not need long specific URI.
    # But during Lithium development, Post ceased to do merge, so those Keywords do not work anymore.
    # This Keyword can still be used with specific URI to create a new container and fail if a container was already present.
    ${response}=    RequestsLibrary.Post    ${NetconfViaRestconf__active_session}    ${uri_part}    data=${xml_data}
    BuiltIn.Log    ${response.text}
    BuiltIn.Should_Be_Empty    ${response.text}
    BuiltIn.Should_Be_Equal_As_Strings    ${response.status_code}    204

Post_Xml_Template_Folder_Via_Restconf
    [Arguments]    ${folder}    ${mapping_as_string}={}
    [Documentation]    Resolve URI and data from folder, POST to restconf.
    ${uri_part}=    Resolve_URI_From_Template_Folder    ${folder}    ${mapping_as_string}
    ${xml_data}=    Resolve_Xml_Data_From_Template_Folder    ${folder}    ${mapping_as_string}
    Post_Xml_Via_Restconf    ${uri_part}    ${xml_data}

Put_Xml_Via_Restconf
    [Arguments]    ${uri_part}    ${xml_data}
    [Documentation]    Put XML data to given controller-config URI, check reponse text is empty and status_code is one of allowed ones.
    BuiltIn.Log    ${uri_part}
    BuiltIn.Log    ${xml_data}
    ${response}=    RequestsLibrary.Put    ${NetconfViaRestconf__active_session}    ${uri_part}    data=${xml_data}
    BuiltIn.Log    ${response.text}
    BuiltIn.Log    ${response.status_code}
    BuiltIn.Should_Be_Empty    ${response.text}
    BuiltIn.Should_Contain    ${allowed_status_codes}    ${response.status_code}

Put_Xml_Template_Folder_Via_Restconf
    [Arguments]    ${folder}    ${mapping_as_string}={}
    [Documentation]    Resolve URI and data from folder, PUT to controller config.
    ${uri_part}=    Resolve_URI_From_Template_Folder    ${folder}    ${mapping_as_string}
    ${xml_data}=    Resolve_Xml_Data_From_Template_Folder    ${folder}    ${mapping_as_string}
    Put_Xml_Via_Restconf    ${uri_part}    ${xml_data}

Delete_Via_Restconf
    [Arguments]    ${uri_part}
    [Documentation]    Delete resource at controller-config URI, check reponse text is empty and status_code is 204.
    BuiltIn.Log    ${uri_part}
    ${response}=    RequestsLibrary.Delete    ${NetconfViaRestconf__active_session}    ${uri_part}
    BuiltIn.Log    ${response.text}
    BuiltIn.Should_Be_Empty    ${response.text}
    BuiltIn.Should_Contain    ${allowed_status_codes}    ${response.status_code}

Delete_Xml_Template_Folder_Via_Restconf
    [Arguments]    ${folder}    ${mapping_as_string}={}
    [Documentation]    Resolve URI from folder, DELETE from controller config.
    ${uri_part}=    Resolve_URI_From_Template_Folder    ${folder}    ${mapping_as_string}
    Delete_Via_Restconf    ${uri_part}

Create_NVR_Session
    [Arguments]    ${name}    ${host}
    [Documentation]    Create a Netconf Via Restconf session pointing to the given host with the given name. The new session is NOT made active.
    RequestsLibrary.Create_Session    ${name}    http://${host}:${RESTCONFPORT}${CONFIG_API}    headers=${HEADERS_XML}    auth=${AUTH}

Activate_NVR_Session
    [Arguments]    ${name}
    [Documentation]    Activate the given session and return the name of the previously active session.
    ${result}=    BuiltIn.Set_Variable    ${NetconfViaRestconf__active_session}
    BuiltIn.Set_Suite_Variable    ${NetconfViaRestconf__active_session}    ${name}
    [Return]    ${result}
